//! Build script for rasterix.
//!
//! Generates Rust code from XML fixtures at compile time for roundtrip testing.
//! The generated code is placed in OUT_DIR and included in tests via `include!`.

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=../testdata/valid/");
    println!("cargo:rerun-if-changed=build.rs");

    let out_dir = env::var("OUT_DIR").unwrap();
    let generated_dir = Path::new(&out_dir).join("generated");
    fs::create_dir_all(&generated_dir).unwrap();

    // List of fixtures to generate code for
    let fixtures = [
        ("simple_fixed", "simple_fixed.xml"),
        ("multi_item_record", "multi_item_record.xml"),
        ("extended_multi_part", "extended_multi_part.xml"),
        ("enum_basic", "enum_basic.xml"),
        ("compound_simple", "compound_simple.xml"),
        ("repetitive_basic", "repetitive_basic.xml"),
        ("epb_field", "epb_field.xml"),
        ("explicit_item", "explicit_item.xml"),
        ("spare_bits", "spare_bits.xml"),
    ];

    // Generate mod.rs that includes all generated modules
    let mut mod_content = String::from(
        "// AUTO-GENERATED by build.rs - DO NOT EDIT\n\
         //\n\
         // This module contains code generated from XML fixtures for roundtrip testing.\n\n"
    );

    for (module_name, xml_file) in &fixtures {
        let xml_path = Path::new("../testdata/valid").join(xml_file);

        if !xml_path.exists() {
            println!("cargo:warning=Fixture not found: {}", xml_path.display());
            continue;
        }

        // Read XML content
        let xml_content = match fs::read_to_string(&xml_path) {
            Ok(content) => content,
            Err(e) => {
                println!("cargo:warning=Failed to read {}: {}", xml_path.display(), e);
                continue;
            }
        };

        // Generate Rust code using rasterix-codegen
        match generate_code(&xml_content) {
            Ok(code) => {
                let output_path = generated_dir.join(format!("{}.rs", module_name));

                // Write the generated module with test helpers
                let module_code = format!(
                    "// AUTO-GENERATED from {} - DO NOT EDIT\n\n\
                     {}\n",
                    xml_file,
                    code
                );

                fs::write(&output_path, &module_code).unwrap();
                mod_content.push_str(&format!("pub mod {};\n", module_name));

                println!("cargo:warning=Generated: {}", output_path.display());
            }
            Err(e) => {
                println!("cargo:warning=Failed to generate code for {}: {}", xml_file, e);
            }
        }
    }

    // Write the mod.rs file
    let mod_path = generated_dir.join("mod.rs");
    fs::write(&mod_path, &mod_content).unwrap();

    // Write the path to generated dir for tests to find
    let generated_path_file = Path::new(&out_dir).join("generated_path.txt");
    fs::write(&generated_path_file, generated_dir.to_str().unwrap()).unwrap();
}

/// Generate Rust code from XML content using rasterix-codegen.
fn generate_code(xml_content: &str) -> Result<String, String> {
    // We need to use the codegen crate directly
    // Since build.rs runs before the crate is compiled, we use a subprocess approach
    // or inline the generation logic

    // For simplicity, we'll inline the generation logic here
    // This requires adding rasterix-codegen as a build dependency

    use rasterix_codegen::parse::parser::parse_category;
    use rasterix_codegen::transform::transformer::to_ir;
    use rasterix_codegen::generate::generate;

    let category = parse_category(xml_content)
        .map_err(|e| format!("Parse error: {}", e))?;

    let ir = std::panic::catch_unwind(|| to_ir(category))
        .map_err(|_| "Transform/validation error".to_string())?;

    let tokens = generate(&ir);
    Ok(tokens.to_string())
}
