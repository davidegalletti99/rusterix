# ! [allow (unused_imports)] # ! [allow (dead_code)] use rusterix :: rcore :: { BitReader , BitWriter , DecodeError , Fspec , Decode , Encode } ; use std :: io :: { Read , Write } ; # [doc = r" ASTERIX Category record."] # [doc = r" "] # [doc = r" Contains optional data items, each controlled by a bit in the FSPEC."] # [derive (Debug , Clone , PartialEq)] pub struct Cat001Record { pub item100 : Option < Item100 > } impl Cat001Record { # [doc = r" Decodes a record from a binary stream."] # [doc = r" "] # [doc = r" Reads the FSPEC to determine which items are present, then"] # [doc = r" decodes only the present items."] # [doc = r" "] # [doc = r" # Arguments"] # [doc = r" "] # [doc = r" * `reader` - The input stream to read from"] # [doc = r" "] # [doc = r" # Errors"] # [doc = r" "] # [doc = r" Returns an error if reading or parsing fails."] pub fn decode < R : std :: io :: Read > (reader : & mut R) -> Result < Self , DecodeError > { let fspec = Fspec :: read (reader) ? ; let mut bit_reader = BitReader :: new (reader) ; Ok (Self { item100 : if fspec . is_set (0usize , 0u8) { Some (Item100 :: decode (& mut bit_reader) ?) } else { None } }) } } impl Cat001Record { # [doc = r" Encodes a record to a binary stream."] # [doc = r" "] # [doc = r" Automatically constructs the FSPEC based on which items are present,"] # [doc = r" then encodes all present items."] # [doc = r" "] # [doc = r" # Arguments"] # [doc = r" "] # [doc = r" * `writer` - The output stream to write to"] # [doc = r" "] # [doc = r" # Errors"] # [doc = r" "] # [doc = r" Returns an error if writing fails."] pub fn encode < W : std :: io :: Write > (& self , writer : & mut W) -> Result < () , DecodeError > { let mut fspec = Fspec :: new () ; if self . item100 . is_some () { fspec . set (0usize , 0u8) ; } fspec . write (writer) ? ; let mut bit_writer = BitWriter :: new (writer) ; if let Some (ref item) = self . item100 { item . encode (& mut bit_writer) ? ; } bit_writer . flush () ? ; Ok (()) } } # [derive (Debug , Clone , PartialEq)] pub struct Item100Sub0 { pub flags : u8 } # [derive (Debug , Clone , PartialEq)] pub struct Item100Sub1 { pub data : u16 } # [derive (Debug , Clone , PartialEq)] pub struct Item100 { pub sub0 : Option < Item100Sub0 > , pub sub1 : Option < Item100Sub1 > } impl Decode for Item100Sub0 { fn decode < R : std :: io :: Read > (reader : & mut BitReader < R > ,) -> Result < Self , DecodeError > { let flags = reader . read_bits (8usize) ? as u8 ; Ok (Self { flags }) } } impl Decode for Item100Sub1 { fn decode < R : std :: io :: Read > (reader : & mut BitReader < R > ,) -> Result < Self , DecodeError > { let data = reader . read_bits (16usize) ? as u16 ; Ok (Self { data }) } } impl Item100 { pub fn decode < R : std :: io :: Read > (reader : & mut R ,) -> Result < Self , DecodeError > { let fspec = Fspec :: read (reader) ? ; let mut reader = BitReader :: new (reader) ; let sub0 = if fspec . is_set (0usize , 0u8) { Some (Item100Sub0 :: decode (& mut reader) ?) } else { None } ; let sub1 = if fspec . is_set (0usize , 1u8) { Some (Item100Sub1 :: decode (& mut reader) ?) } else { None } ; Ok (Self { sub0 , sub1 }) } } impl Encode for Item100Sub0 { fn encode < W : std :: io :: Write > (& self , writer : & mut BitWriter < W > ,) -> Result < () , DecodeError > { writer . write_bits (self . flags as u64 , 8usize) ? ; Ok (()) } } impl Encode for Item100Sub1 { fn encode < W : std :: io :: Write > (& self , writer : & mut BitWriter < W > ,) -> Result < () , DecodeError > { writer . write_bits (self . data as u64 , 16usize) ? ; Ok (()) } } impl Item100 { pub fn encode < W : std :: io :: Write > (& self , writer : & mut W ,) -> Result < () , DecodeError > { let mut fspec = Fspec :: new () ; if self . sub0 . is_some () { fspec . set (0usize , 0u8) ; } if self . sub1 . is_some () { fspec . set (0usize , 1u8) ; } fspec . write (writer) ? ; let mut writer = BitWriter :: new (writer) ; if let Some (ref sub_data) = self . sub0 { sub_data . encode (& mut writer) ? ; } if let Some (ref sub_data) = self . sub1 { sub_data . encode (& mut writer) ? ; } writer . flush () ? ; Ok (()) } }