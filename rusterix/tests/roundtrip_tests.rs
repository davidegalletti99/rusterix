//! Roundtrip tests for generated ASTERIX code.
//!
//! These tests verify that the code generated by rusterix-codegen correctly
//! implements encode/decode roundtrips. The code is generated at build time
//! from XML fixtures using build.rs.
//!
//! **IMPORTANT**: These tests use REAL GENERATED CODE, not manual implementations.
//! If the code generator changes, these tests will reflect those changes.

mod roundtrip;

// Include the generated modules from build.rs
// This code is generated from testdata/valid/*.xml at compile time
include!(concat!(env!("OUT_DIR"), "/generated/mod.rs"));

use rusterix::rcore::{BitReader, BitWriter, Decode, Encode};
use std::io::Cursor;

// ============================================================================
// Simple Fixed Item Roundtrip Tests
// ============================================================================

#[test]
fn roundtrip_simple_fixed_zeros() {
    use simple_fixed::cat001::*;

    let original = Item010 { sac: 0, sic: 0 };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item010::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

#[test]
fn roundtrip_simple_fixed_max_values() {
    use simple_fixed::cat001::*;

    let original = Item010 { sac: 255, sic: 255 };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item010::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

#[test]
fn roundtrip_simple_fixed_typical() {
    use simple_fixed::cat001::*;

    let original = Item010 { sac: 42, sic: 128 };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item010::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

#[test]
fn roundtrip_simple_fixed_bytes() {
    use simple_fixed::cat001::*;

    // Known byte sequence: sac=42 (0x2A), sic=128 (0x80)
    let bytes = [0x2A, 0x80];

    let mut reader = BitReader::new(Cursor::new(&bytes));
    let item = Item010::decode(&mut reader).unwrap();

    assert_eq!(item.sac, 42);
    assert_eq!(item.sic, 128);

    // Re-encode
    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        item.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    assert_eq!(&bytes[..], &buffer[..]);
}

// ============================================================================
// Multi-Item Record Roundtrip Tests
// ============================================================================

#[test]
fn roundtrip_record_all_items() {
    use multi_item_record::cat048::*;

    let original = Record {
        item010: Some(Item010 { sac: 42, sic: 128 }),
        item020: Some(Item020 { typ: 99 }),
        item240: Some(Item240 { aircraft_id: "TEST".to_string() }),
    };

    let mut buffer = Vec::new();
    original.encode(&mut buffer).unwrap();

    let mut reader = Cursor::new(&buffer);
    let decoded = Record::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

#[test]
fn roundtrip_record_partial_items() {
    use multi_item_record::cat048::*;

    let original = Record {
        item010: Some(Item010 { sac: 1, sic: 2 }),
        item020: None,
        item240: None,
    };

    let mut buffer = Vec::new();
    original.encode(&mut buffer).unwrap();

    let mut reader = Cursor::new(&buffer);
    let decoded = Record::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

#[test]
fn roundtrip_record_empty() {
    use multi_item_record::cat048::*;

    let original = Record {
        item010: None,
        item020: None,
        item240: None,
    };

    let mut buffer = Vec::new();
    original.encode(&mut buffer).unwrap();

    let mut reader = Cursor::new(&buffer);
    let decoded = Record::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

// ============================================================================
// String Field Roundtrip Tests
// ============================================================================

#[test]
fn roundtrip_string_field_exact_length() {
    use multi_item_record::cat048::*;

    // 6-byte field with exactly 6 characters
    let original = Item240 { aircraft_id: "ABCDEF".to_string() };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item240::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

#[test]
fn roundtrip_string_field_shorter_than_field() {
    use multi_item_record::cat048::*;

    // 6-byte field with only 3 characters — should be space-padded on wire
    let original = Item240 { aircraft_id: "ABC".to_string() };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    // Verify wire format: 'A' 'B' 'C' ' ' ' ' ' '
    assert_eq!(buffer.len(), 6);
    assert_eq!(buffer, vec![0x41, 0x42, 0x43, 0x20, 0x20, 0x20]);

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item240::decode(&mut reader).unwrap();

    assert_eq!(decoded, original);
}

#[test]
fn roundtrip_string_field_empty() {
    use multi_item_record::cat048::*;

    // Empty string — all spaces on wire
    let original = Item240 { aircraft_id: "".to_string() };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    // Should be 6 space bytes
    assert_eq!(buffer, vec![0x20, 0x20, 0x20, 0x20, 0x20, 0x20]);

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item240::decode(&mut reader).unwrap();

    assert_eq!(decoded, original);
}

#[test]
fn roundtrip_string_field_known_bytes() {
    use multi_item_record::cat048::*;

    // Decode from known byte sequence: "BAW123" (British Airways callsign)
    let bytes = [0x42, 0x41, 0x57, 0x31, 0x32, 0x33]; // "BAW123"

    let mut reader = BitReader::new(Cursor::new(&bytes));
    let item = Item240::decode(&mut reader).unwrap();

    assert_eq!(item.aircraft_id, "BAW123");

    // Re-encode and verify exact bytes
    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        item.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    assert_eq!(&bytes[..], &buffer[..]);
}

#[test]
fn roundtrip_string_field_in_record() {
    use multi_item_record::cat048::*;

    // String field only in record (other items absent)
    let original = Record {
        item010: None,
        item020: None,
        item240: Some(Item240 { aircraft_id: "DLH42".to_string() }),
    };

    let mut buffer = Vec::new();
    original.encode(&mut buffer).unwrap();

    let mut reader = Cursor::new(&buffer);
    let decoded = Record::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

// ============================================================================
// Enum Roundtrip Tests
// ============================================================================

#[test]
fn roundtrip_enum_known_values() {
    use enum_basic::cat001::*;

    // Test with known enum values
    let original = Item010 {
        target_type: TargetType::Psr,
    };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item010::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

#[test]
fn roundtrip_enum_all_variants() {
    use enum_basic::cat001::*;

    for variant in [TargetType::Psr, TargetType::Ssr] {
        let original = Item010 {
            target_type: variant.clone(),
        };

        let mut buffer = Vec::new();
        {
            let mut writer = BitWriter::new(&mut buffer);
            original.encode(&mut writer).unwrap();
            writer.flush().unwrap();
        }

        let mut reader = BitReader::new(Cursor::new(&buffer));
        let decoded = Item010::decode(&mut reader).unwrap();

        assert_eq!(original, decoded, "Failed for variant {:?}", variant);
    }
}

// ============================================================================
// Extended Item Roundtrip Tests
// ============================================================================

#[test]
fn roundtrip_extended_single_part() {
    use extended_multi_part::cat048::*;

    // Test with only the first part present
    // Part0 has fields: a (3 bits), b (4 bits)
    let original = Item020 {
        part0: Item020Part0 { a: 5, b: 10 },
        part1: None,
    };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item020::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

#[test]
fn roundtrip_extended_two_parts() {
    use extended_multi_part::cat048::*;

    // Test with both parts present
    // Part0: a (3 bits), b (4 bits)
    // Part1: c (5 bits)
    let original = Item020 {
        part0: Item020Part0 { a: 5, b: 10 },
        part1: Some(Item020Part1 { c: 20 }),
    };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item020::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

// ============================================================================
// Compound Item Roundtrip Tests
// ============================================================================

#[test]
fn roundtrip_compound_all_subitems() {
    use compound_simple::cat001::*;

    let original = Item100 {
        sub0: Some(Item100Sub0 { flags: 10 }),
        sub1: Some(Item100Sub1 { data: 20 }),
    };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item100::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

#[test]
fn roundtrip_compound_partial_subitems() {
    use compound_simple::cat001::*;

    let original = Item100 {
        sub0: Some(Item100Sub0 { flags: 10 }),
        sub1: None,
    };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item100::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

// ============================================================================
// Repetitive Item Roundtrip Tests
// ============================================================================

#[test]
fn roundtrip_repetitive_basic() {
    use repetitive_basic::cat001::*;

    // The repetitive_basic.xml fixture has counter="5", meaning exactly 5 elements
    let original = Item070 {
        items: vec![
            Item070Element { azimuth: 100 },
            Item070Element { azimuth: 200 },
            Item070Element { azimuth: 300 },
            Item070Element { azimuth: 400 },
            Item070Element { azimuth: 500 },
        ],
    };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item070::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

#[test]
fn roundtrip_repetitive_boundary_values() {
    use repetitive_basic::cat001::*;

    // Test with boundary values for 16-bit azimuth field
    let original = Item070 {
        items: vec![
            Item070Element { azimuth: 0 },
            Item070Element { azimuth: 1 },
            Item070Element { azimuth: 32767 },
            Item070Element { azimuth: 32768 },
            Item070Element { azimuth: 65535 },
        ],
    };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item070::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

// ============================================================================
// EPB (Optional Field) Roundtrip Tests
// ============================================================================

#[test]
fn roundtrip_epb_present() {
    use epb_field::cat001::*;

    let original = Item010 {
        optional_value: Some(12345),
    };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item010::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

#[test]
fn roundtrip_epb_absent() {
    use epb_field::cat001::*;

    let original = Item010 {
        optional_value: None,
    };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item010::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

// ============================================================================
// Spare Bits Roundtrip Tests
// ============================================================================

#[test]
fn roundtrip_spare_bits() {
    use spare_bits::cat001::*;

    let original = Item010 { data: 42 };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item010::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

// ============================================================================
// Explicit Item Roundtrip Tests
// ============================================================================

#[test]
fn roundtrip_explicit_item() {
    use explicit_item::cat001::*;

    let original = Item060 {
        altitude: 1000,
        speed: 250,
    };

    let mut buffer = Vec::new();
    {
        let mut writer = BitWriter::new(&mut buffer);
        original.encode(&mut writer).unwrap();
        writer.flush().unwrap();
    }

    let mut reader = BitReader::new(Cursor::new(&buffer));
    let decoded = Item060::decode(&mut reader).unwrap();

    assert_eq!(original, decoded);
}

// ============================================================================
// Edge Cases
// ============================================================================

#[test]
fn roundtrip_boundary_values() {
    use simple_fixed::cat001::*;

    for &value in &[0u8, 1, 127, 128, 254, 255] {
        let original = Item010 { sac: value, sic: value };

        let mut buffer = Vec::new();
        {
            let mut writer = BitWriter::new(&mut buffer);
            original.encode(&mut writer).unwrap();
            writer.flush().unwrap();
        }

        let mut reader = BitReader::new(Cursor::new(&buffer));
        let decoded = Item010::decode(&mut reader).unwrap();

        assert_eq!(original, decoded, "Failed for value {}", value);
    }
}
